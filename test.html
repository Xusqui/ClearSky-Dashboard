<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Centrar imagen lunar por coordenadas selenográficas</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    /* contenedor de visualización (viewport) */
    #viewer{
      position:relative;
      width:100vw;
      height:100vh;
      overflow:hidden;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* la imagen se posiciona absoluta y se pinta a tamaño natural (1:1). */
    #moonImage{
      position:absolute;
      top:0;left:0;
      image-rendering:pixelated; /* útil si la imagen es muy grande y quieres ver píxeles al 1:1 */
      -webkit-user-drag: none;
      user-drag: none;
      user-select: none;
      transform-origin: 0 0; /* para transformaciones en px */
    }

    /* panel de control sencillo */
    #controls{
      position:fixed;
      right:12px;top:12px;
      background:rgba(255,255,255,0.95);
      color:#000;padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.35);max-width:320px;
      font-size:14px;z-index:30
    }
    #controls label{display:block;margin-top:6px;font-weight:600}
    #controls input{width:100%;box-sizing:border-box;padding:6px;margin-top:4px}
    #controls button{margin-top:8px;padding:8px 10px;width:100%}

    /* indicación del punto marcado */
    #marker{
      position:fixed;z-index:25;pointer-events:none;width:18px;height:18px;margin-left:-9px;margin-top:-9px;border-radius:50%;border:2px solid #fff;background:rgba(255,0,0,0.9);box-shadow:0 0 8px rgba(255,0,0,0.6)
    }

    footer{position:fixed;left:12px;bottom:12px;color:#fff;background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:6px}
  </style>
</head>
<body>

<div id="viewer" aria-live="polite">
  <!-- la imagen puede ser local (miservidor/imagenes/luna_12000.png) o remota. -->
  <img id="moonImage" src="./static/images/hires/lunar-100-2.jpg" alt="Imagen lunar" crossorigin="anonymous">
  <div id="marker" style="display:none"></div>
</div>

<div id="controls">
  <div style="font-weight:700;margin-bottom:6px">Centrar en coordenadas selenográficas</div>
  <label for="lon">Longitud (°) — selenográfica (este +, oeste -)</label>
  <input id="lon" type="number" step="0.0001" value="0">

  <label for="lat">Latitud (°) — selenográfica (norte +, sur -)</label>
  <input id="lat" type="number" step="0.0001" value="0">

  <label for="centerLon">Longitud central de la imagen (°) — opcional</label>
  <input id="centerLon" type="number" step="0.0001" value="0">
  <small>Si la imagen está centrada en la cara visible, déjalo a 0.</small>

  <label style="margin-top:8px">Ajustes de imagen (opcional)</label>
  <div style="display:flex;gap:6px">
    <input id="cx" type="number" step="1" placeholder="cx px" style="flex:1" />
    <input id="cy" type="number" step="1" placeholder="cy px" style="flex:1" />
  </div>
  <input id="radius" type="number" step="1" placeholder="radio en px (opcional)" />
  <small>Si lo dejas vacío se calculará asumiendo disco centrado en la imagen con radio = min(naturalWidth,naturalHeight)/2 * 0.95</small>

  <button id="centerBtn">Centrar pantalla (1:1)</button>
  <button id="markBtn" style="background:#222;color:#fff">Marcar punto</button>
  <button id="resetBtn" style="background:#f2f2f2">Reset posición</button>
</div>

<footer>Imagen mostrada al tamaño natural (1:1 de píxeles). Arrastra la ventana o cambia valores y pulsa "Centrar".</footer>

<script>
// Conversión y centrado usando PROYECCIÓN ORTOGRÁFICA
// Supuestos y notas:
// - La imagen contiene la cara visible centrada (sub-Earth long = 0° por defecto).
// - Para cada punto selenográfico (lon, lat): convertir a coordenadas cartesianas en la esfera,
//   proyectar ortográficamente sobre el plano de la imagen y mapear a píxeles.
// - Fórmulas (lon,lat en radianes):
//     x = cos(lat) * sin(lon_rel)
//     y = sin(lat)
//     z = cos(lat) * cos(lon_rel)
//   Sólo son visibles los puntos con z >= 0.
// - Pixel = (cx + R * x, cy - R * y) donde cx,cy es el centro del disco en píxeles y R su radio.

(function(){
  const img = document.getElementById('moonImage');
  const viewer = document.getElementById('viewer');
  const marker = document.getElementById('marker');

  const lonInput = document.getElementById('lon');
  const latInput = document.getElementById('lat');
  const centerLonInput = document.getElementById('centerLon');
  const cxInput = document.getElementById('cx');
  const cyInput = document.getElementById('cy');
  const radiusInput = document.getElementById('radius');

  const centerBtn = document.getElementById('centerBtn');
  const markBtn = document.getElementById('markBtn');
  const resetBtn = document.getElementById('resetBtn');

  // espera a que la imagen cargue para conocer naturalWidth/Height
  img.addEventListener('load', ()=>{
    // forzamos tamaño natural: pintamos en sus píxeles sin escalar
    img.style.width = img.naturalWidth + 'px';
    img.style.height = img.naturalHeight + 'px';

    // opcional: si quieres centrar inicialmente la imagen en el viewer
    resetPosition();
  });

  function deg2rad(d){return d*Math.PI/180}

  function selenographicToPixel(lonDeg, latDeg, opts){
    // opts: {centerLonDeg, cx, cy, R}
    const lon = deg2rad(lonDeg);
    const lat = deg2rad(latDeg);
    const centerLon = deg2rad(opts.centerLonDeg||0);
    const lon_rel = lon - centerLon;

    // ortográfica
    // Factores de corrección para ajustar a la proyección real de la imagen
const lonCorr = 1;  // Corrige la compresión horizontal
const latCorr = 1;  // Corrige la compresión vertical

const x = Math.cos(lat * latCorr) * Math.sin(lon * lonCorr);
const y = Math.sin(lat * latCorr);
    //const x = Math.cos(lat) * Math.sin(lon_rel);
    //const y = Math.sin(lat);
    const z = Math.cos(lat) * Math.cos(lon_rel);

    // si z < 0 está en la cara oculta
    const visible = (z >= 0);

    const px = opts.cx + opts.R * x;
    const py = opts.cy - opts.R * y; // coordenada de imagen con origen en arriba
    return {px,py,visible,x,y,z};
  }

  function computeDefaultDisk(){
    const W = img.naturalWidth;
    const H = img.naturalHeight;
    const cx = typeof cxInput.value === 'string' && cxInput.value.trim() !== '' ? Number(cxInput.value) : Math.floor(W/2);
    const cy = typeof cyInput.value === 'string' && cyInput.value.trim() !== '' ? Number(cyInput.value) : Math.floor(H/2);
    const R = (radiusInput.value && Number(radiusInput.value) > 0) ? Number(radiusInput.value) : Math.floor(Math.min(W,H)/2);
    return {cx,cy,R};
  }

  function centerOn(lonDeg, latDeg){
    const centerLonDeg = Number(centerLonInput.value) || 0;
    const disk = computeDefaultDisk();
    const res = selenographicToPixel(lonDeg, latDeg, {centerLonDeg, cx:disk.cx, cy:disk.cy, R:disk.R});

    // colocamos la imagen de manera que el pixel res.px,res.py quede en el centro del viewport
    const vw = viewer.clientWidth;
    const vh = viewer.clientHeight;

    const targetLeft = Math.round(vw/2 - res.px);
    const targetTop  = Math.round(vh/2 - res.py);

    img.style.left = targetLeft + 'px';
    img.style.top  = targetTop + 'px';

    // colocamos el marcador en el centro de la pantalla si está visible
    if(res.visible){
      marker.style.display = 'block';
      marker.style.left = (vw/2) + 'px';
      marker.style.top  = (vh/2) + 'px';
      marker.title = `Lon ${lonDeg}°, Lat ${latDeg}° (visible)`;
    } else {
      marker.style.display = 'none';
      alert('El punto calculado está en la cara oculta (z < 0). No se puede marcar en la cara visible.');
    }

    return res;
  }

  function resetPosition(){
    // Sitúa la imagen con su centro aproximado en el centro del viewport
    const disk = computeDefaultDisk();
    const vw = viewer.clientWidth;
    const vh = viewer.clientHeight;
    const left = Math.round(vw/2 - disk.cx);
    const top  = Math.round(vh/2 - disk.cy);
    img.style.left = left + 'px';
    img.style.top  = top + 'px';
    marker.style.display = 'none';
  }

  centerBtn.addEventListener('click', ()=>{
    const lon = Number(lonInput.value);
    const lat = Number(latInput.value);
    if(Number.isNaN(lon) || Number.isNaN(lat)) { alert('Introduce lon y lat válidos'); return; }
    const res = centerOn(lon,lat);
    console.log('Resultado:',res);
  });

  markBtn.addEventListener('click', ()=>{
    const lon = Number(lonInput.value);
    const lat = Number(latInput.value);
    if(Number.isNaN(lon) || Number.isNaN(lat)) { alert('Introduce lon y lat válidos'); return; }
    const centerLonDeg = Number(centerLonInput.value) || 0;
    const disk = computeDefaultDisk();
    const res = selenographicToPixel(lon, lat, {centerLonDeg, cx:disk.cx, cy:disk.cy, R:disk.R});

    // marker at absolute image position -> translate to screen coords
    const imgLeft = parseInt(img.style.left || 0, 10);
    const imgTop  = parseInt(img.style.top  || 0, 10);
    const screenX = imgLeft + res.px;
    const screenY = imgTop  + res.py;

    if(res.visible){
      marker.style.display = 'block';
      marker.style.left = screenX + 'px';
      marker.style.top  = screenY + 'px';
      marker.title = `Lon ${lon}°, Lat ${lat}°`;
    } else {
      alert('El punto está en la cara oculta (z < 0). No se puede marcar en la cara visible.');
    }
  });

  resetBtn.addEventListener('click', ()=>{
    resetPosition();
  });

  // permite arrastrar la imagen con el ratón para pequeños ajustes (panning)
  (function enableDrag(){
    let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;
    img.addEventListener('mousedown', (e)=>{
      dragging=true; startX=e.clientX; startY=e.clientY;
      startLeft = parseInt(img.style.left||0,10); startTop = parseInt(img.style.top||0,10);
      e.preventDefault();
    });
    window.addEventListener('mousemove',(e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX; const dy = e.clientY - startY;
      img.style.left = (startLeft + dx) + 'px';
      img.style.top  = (startTop  + dy) + 'px';
    });
    window.addEventListener('mouseup',()=>{dragging=false});

    // soporta también toque en móviles
    let touchStart=false;
    img.addEventListener('touchstart',(ev)=>{touchStart=true; const t=ev.touches[0]; startX=t.clientX; startY=t.clientY; startLeft = parseInt(img.style.left||0,10); startTop = parseInt(img.style.top||0,10);});
    window.addEventListener('touchmove',(ev)=>{ if(!touchStart) return; const t=ev.touches[0]; const dx=t.clientX-startX; const dy=t.clientY-startY; img.style.left=(startLeft+dx)+'px'; img.style.top=(startTop+dy)+'px'; ev.preventDefault();},{passive:false});
    window.addEventListener('touchend',()=>{touchStart=false});
  })();

  // recalcula al redimensionar la ventana para mantener coherencia visual
  window.addEventListener('resize', ()=>{
    // opcional: mantener marcador centrado si estaba centrado
    // aquí simplemente ocultamos marcador para evitar incoherencias
    marker.style.display='none';
  });

})();
</script>
</body>
</html>
